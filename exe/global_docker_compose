#!/usr/bin/env ruby

require 'yaml'
require 'thor'
require 'thor/base'

class CLI < Thor

	# @return [Boolean]
	def self.exit_on_failure?
		true
	end

	# For pre-0.18 compatibility
	unless self.class.respond_to?(:no_commands)
		def self.no_commands(&block)
			self.no_tasks(&block)
		end
	end

	no_commands do

		# @param cmd [String]
		# @return [Boolean, nil]
		def run_command(cmd)
			puts "-> #{cmd}"
			system(cmd)
		end

		# @return [String]
		def dc_file
			"#{__dir__}/../lib/docker-compose.yml"
		end

		# @return [Array<String>]
		def configured_services
			dc_config = YAML.load(File.read(self.dc_file))
			services = dc_config['services'].keys
			if options[:compose_file]
				dc_config = YAML.load(File.read(options[:compose_file]))
				services += dc_config['services'].keys
			end
			services
		end

		# @param command [String]
		# @param service [String]
		def validate_service(command, service)
			service_not_found!(command, service) unless configured_services.include?(service)
		end

		# @param command [String]
		# @param service [String]
		def service_not_found!(command, service)
			say "Cannot execute command #{command} - #{service} is not a known service!", :red
			say "Known services: #{configured_services.join(' ')}"
			exit(1)
		end

		# @param command [String]
		# @return [String]
		def service_string(command)
			if options[:services].nil? || options[:services].empty?
				say "No services provided for command #{command}! Use the --services option.", :red
				exit(1)
			end

			dc_services = configured_services
			results = []
			options[:services].each do |service|
				if dc_services.include?(service)
					results << service
					if service == 'redis'
						results << 'redisinsight'
					end
				else
					service_not_found!(command, service)
				end
			end
			results.join(' ')
		end

		# @return [String]
		def main_command
			cmd = "docker compose -f #{dc_file}"
			if options[:compose_file]
				cmd << " -f #{options[:compose_file]}"
			end
			cmd
		end

		# @param service [String]
		# @param command [String]
		# @param input_file [String]
		def execute_docker_command(service, command, input_file:nil)
			cmd = "#{main_command} exec #{service} #{command}"
			if input_file
				cmd = "cat #{input_file} | #{main_command} exec -T #{service} #{command}"
			end
			run_command(cmd)
		end

	end

	class_option(:services, type: :array)
	class_option(:compose_file, type: :string)

	desc 'up', 'Creates and starts services'
	def up
		str = service_string('up')
		run_command('aws ecr get-login-password | docker login --password-stdin -u AWS 421990735784.dkr.ecr.us-east-1.amazonaws.com')
		run_command("#{main_command} up -d #{str}")
	end

	desc 'down', 'Stops and removes services, leaving volumes intact'
	def down
		if options[:services] && options[:services].any?
			str = service_string('down')
			run_command("#{main_command} stop #{str}")
			run_command("#{main_command} rm -f #{str}")
		else
			run_command("#{main_command} down")
		end
	end

	desc 'logs', 'Shows logs for your services'
	def logs
		str = service_string('logs')
		run_command("#{main_command} logs -f #{str}")
	end

	desc 'ps', 'Show currently running services'
	def ps
		run_command("#{main_command} ps")
	end

	desc 'exec', 'Run a command on an existing container'
	def exec(service, *command)
		validate_service('exec', service)
		execute_docker_command(service, command.join(' '))
	end

	desc 'mysql', 'Run the MySQL command line'
	def mysql(input=nil)
		# check which version is running
		%w(mysql56 mysql57 mysql8).each do |version|
			if options[:services].include?(version)
				execute_docker_command(version, 'mysql', input_file: input)
				return
			end
		end

		# not found
		say "mysql service not provided! Please use the --services option!", :red
		exit(1)
	end

	desc 'redis_cli', 'Run the Redis command line'
	def redis_cli
		execute_docker_command('redis', 'redis-cli')
	end

end

CLI.start(ARGV)
